var allData = d3.map(allData);
var data2008 = d3.map(data2008);
var data2009 = d3.map(data2009);
var data2010 = d3.map(data2010);
var data2011 = d3.map(data2011);
var data2012 = d3.map(data2012);
var data2013 = d3.map(data2013);

var done = false;

loadData();

var currentYear = getYearForm();
var currentRound = getRoundForm();

function loadData() {
    d3.csv("fullDataNoByes.csv", function (d) {
        var format = d3.time.format("%A%d%B%Y");


        var stripSpace = d.Date;
        stripSpace = stripSpace.replace(/ /g, '');
        return {

            Round: +d.Round,
            Date: format.parse(stripSpace),
            HomeTeam: d['Home Team'],
            HomeScore: +d['Score'].split(' - ')[0],
            AwayScore: +d['Score'].split(' - ')[1],
            HomeWins: 0,
            AwayWins: 0,
            AwayTeam: d['Away Team'],
            Venue: d.Venue
        };


    }, function (error, rows) {
        var i;
        //allData = [1,2,3,4];
        done = true;
        //console.log()

        //var currentData = data2008;
        var index2009 = 0;
        var index2010 = 0;
        var index2011 = 0;
        var index2012 = 0;
        var index2013 = 0;
        for (i = 0; i < rows.length; i++) {
            //console.log(rows[i].Date);
            allData.set(i, rows[i]);
            if (rows[i].Date.getFullYear() == 2008) {
                data2008.set(i, rows[i]);

            }
            else if (rows[i].Date.getFullYear() == 2009) {
                data2009.set(index2009++, rows[i]);
            }
            else if (rows[i].Date.getFullYear() == 2010) {
                data2010.set(index2010++, rows[i]);
            }
            else if (rows[i].Date.getFullYear() == 2011) {
                data2011.set(index2011++, rows[i]);
            }
            else if (rows[i].Date.getFullYear() == 2012) {
                data2012.set(index2012++, rows[i]);
            }
            else if (rows[i].Date.getFullYear() == 2013) {
                data2013.set(index2013++, rows[i]);
            }
        }


        var length = 0;
        for (var key in data2008) {
            if (data2008.hasOwnProperty(key)) {
                length++;
            }
        }
        var length2013 = 0;
        for (var key1 in data2013) {
            if (data2013.hasOwnProperty(key1)) {
                length2013++;
            }
        }

        console.log("loaded");
        manipulateData();


    });
    d3.select("body").style("background-color", "#58ACFA");
    currentYear = getYearForm();
    currentRound = getRoundForm();
}

function getYearText() {
    var yearNum = document.getElementById("years2");
    return yearNum.options[yearNum.selectedIndex].text;

}

function getRoundText() {
    var roundNum = document.getElementById("rounds2");
    return roundNum.options[roundNum.selectedIndex].text;

}

function getYearForm() {
    var yearNum = document.getElementById("years2");
    var yearText = yearNum.options[yearNum.selectedIndex].text;
    if (yearText == "All Years") {
        //console.log("Returning: All Years");
        return allData;
    }
    else if(yearText=="2008") return data2008;
    else if(yearText=="2009") return data2009;
    else if(yearText=="2010") return data2010;
    else if(yearText=="2011") return data2011;
    else if(yearText=="2012") return data2012;
    return data2013;
}

function getRoundForm() {
    //console.log("returning round");
    var roundNum = document.getElementById("rounds2");
    var roundText = roundNum.options[roundNum.selectedIndex].text;
    if (roundText == "All Rounds") {
        //console.log("Returning: " + 17);
        return 17;
    }
    var temp = roundText.split("Round ")[1];
    var toReturn = parseInt(temp);
    //console.log(+toReturn);
    return +toReturn;
}


var data = {};


function manipulateData() {

    data = allData;
    var isAllData = false;

    var currentData = getYearForm();
    if(currentData==allData) isAllData=true;

    //scores for each team

    //console.log("currentData len: " + currentData.size());

    var dataRounds = d3.map(dataRounds);

    for (var i = 0; i < currentData.size(); i++) {
        var curRound = currentData.get(i).Round;
        //add the current round to the array if its not there
        if (!dataRounds.has(curRound)) {
            //initialize the map inside the current round
            if (curRound == 1) {
                dataRounds.set(curRound, d3.map());
                console.log(dataRounds.get(curRound));
            }
            else {
                //dataRounds.set(curRound, d3.map());
                //console.log("first" + curRound);
                var toSet = dataRounds.get(curRound - 1);
                var count = 1;
                while (toSet == undefined) {
                    toSet = dataRounds.get(curRound - count);
                    count++;
                }
                //console.log(toSet);
                //console.log("second");
                //var arraty = []
                //var newS =  arraty.slice();
                var newMap = owl.deepCopy(toSet);
                //for (var x in toSet)
                //    newMap[x] = toSet[x];
                //this is causing the error
                //want it so it adds teams points and score for each round
                //console.log("Setting ROUND: "+curRound+" toSet "+toSet.get("Central Pulse"));
                //console.log(newMap.size());
                dataRounds.set(curRound, newMap);
            }

            //get the map that will contain all the teams
            //for the current round
            var curMap = dataRounds.get(curRound);
            //console.log("retrieving map " + curRound + " " + curMap);
            //console.log(dataRounds);

            //initialize Home team
            if (!curMap.has(currentData.get(i).HomeTeam)) {
                if (currentData.get(i).HomeScore > currentData.get(i).AwayScore) {
                    //if they won there first game
                    //console.log("initializing home team");
                    curMap.set(currentData.get(i).HomeTeam, new Team(2, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound));
                }
                else {
                    //if not
                    curMap.set(currentData.get(i).HomeTeam, new Team(0, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound));

                }
            }

            //add stats to home team
            //if they are already in the map
            else if (curMap.has(currentData.get(i).HomeTeam)) {
                //console.log("error here:");
                //console.log(curMap);
                //console.log(curMap.get(currentData.get(i).HomeTeam));
                //curMap returns a TEAM object
                var curHomeTeam = curMap.get(currentData.get(i).HomeTeam);


                if (currentData.get(i).HomeScore > currentData.get(i).AwayScore) {
                    //check this is working
                    //console.log("here adding stats home team won already in array "+curHomeTeam.name);
                    curHomeTeam.round = curRound;
                    curHomeTeam.points = curHomeTeam.points + 2;
                    curHomeTeam.goalsFor = curHomeTeam.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam.goalsAgainst = curHomeTeam.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam.gamesPlayed = curHomeTeam.gamesPlayed + 1;
                    //console.log(curHomeTeam);
                }
                else if (currentData.get(i).HomeScore < currentData.get(i).AwayScore) {
                    //check this is working
                    //console.log("here adding stats home team lost already in the array "+curHomeTeam.name);
                    curHomeTeam.round = curRound;
                    curHomeTeam.points = curHomeTeam.points + 0;
                    curHomeTeam.goalsFor = curHomeTeam.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam.goalsAgainst = curHomeTeam.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam.gamesPlayed = curHomeTeam.gamesPlayed + 1;
                    //console.log(curHomeTeam);
                }

            }

            //initialize Away team
            if (!curMap.has(currentData.get(i).AwayTeam)) {
                //if they won
                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    curMap.set(currentData.get(i).AwayTeam, new Team(2, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound));
                }
                //if they lost
                else {
                    curMap.set(currentData.get(i).AwayTeam, new Team(0, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound));
                }
            }
            //add stats to away team
            else if (curMap.has(currentData.get(i).AwayTeam)) {
                //console.log("error here:");
                //console.log(curMap);
                //console.log(curMap.get(currentData.get(i).HomeTeam));
                //curMap returns a TEAM object
                var curAwayTeam = curMap.get(currentData.get(i).AwayTeam);

                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    //check this is working
                    //console.log("here adding stats away team won already in the array "+curAwayTeam.name);
                    curAwayTeam.round = curRound;
                    curAwayTeam.points = curAwayTeam.points + 2;
                    curAwayTeam.goalsFor = curAwayTeam.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam.goalsAgainst = curAwayTeam.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam.gamesPlayed = curAwayTeam.gamesPlayed + 1;
                    //console.log(curAwayTeam);
                }
                //away team lost
                else if (currentData.get(i).AwayScore < currentData.get(i).HomeScore) {
                    //console.log("here adding stats away team lost already in the array "+curAwayTeam.name);
                    curAwayTeam.round = curRound;
                    curAwayTeam.points = curAwayTeam.points + 0;
                    curAwayTeam.goalsFor = curAwayTeam.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam.goalsAgainst = curAwayTeam.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam.gamesPlayed = curAwayTeam.gamesPlayed + 1;
                    //console.log(curAwayTeam);
                }


            }

        }
        //already has current round eg rnd 1
        else if (dataRounds.has(curRound)) {

            //get the map that will contain all the teams
            //for the current round
            var currentMap = dataRounds.get(curRound);
            //initialize Home team
            if (!currentMap.has(currentData.get(i).HomeTeam)) {
                var homeTeam = currentData.get(i);
                var awayteam = currentData.get(i);
                if (homeTeam.HomeScore > awayteam.AwayScore) {
                    currentMap.set(currentData.get(i).HomeTeam, new Team(2, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound));
                }
                else {
                    currentMap.set(currentData.get(i).HomeTeam, new Team(0, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound));
                }
            }
            //add points home team
            else if (currentMap.has(currentData.get(i).HomeTeam)) {
                var curHomeTeam2 = currentMap.get(currentData.get(i).HomeTeam);
                if(isAllData){
                    curHomeTeam2 = curMap.get(currentData.get(i).HomeTeam);
                    //console.log("went in here");
                }
                if (currentData.get(i).HomeScore > currentData.get(i).AwayScore) {
                    //console.log("here adding stats home team won already in array "+curHomeTeam2.name);
                    curHomeTeam2.round = curRound;
                    curHomeTeam2.points = curHomeTeam2.points + 2;
                    curHomeTeam2.goalsFor = curHomeTeam2.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam2.goalsAgainst = curHomeTeam2.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam2.gamesPlayed = curHomeTeam2.gamesPlayed + 1;
                    //console.log(curHomeTeam2);
                }
                else {
                    //console.log("here adding stats home team lost already in array "+curHomeTeam2.name);
                    curHomeTeam2.round = curRound;
                    curHomeTeam2.points = curHomeTeam2.points + 0;
                    curHomeTeam2.goalsFor = curHomeTeam2.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam2.goalsAgainst = curHomeTeam2.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam2.gamesPlayed = curHomeTeam2.gamesPlayed + 1;
                    //console.log(curHomeTeam2);
                }

            }

            //initialize away team
            if (!currentMap.has(currentData.get(i).AwayTeam)) {
                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    currentMap.set(currentData.get(i).AwayTeam, new Team(2, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound));
                }
                else {
                    currentMap.set(currentData.get(i).AwayTeam, new Team(0, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound));
                }
            }

            //gotta add stats if they are already there. (only for 2011)
            else if (currentMap.has(currentData.get(i).AwayTeam)) {
                var curAwayTeam2 = currentMap.get(currentData.get(i).AwayTeam);
                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    //console.log("here adding stats away team won already in array "+curAwayTeam2.name);
                    curAwayTeam2.round = curRound;
                    curAwayTeam2.points = curAwayTeam2.points + 2;
                    curAwayTeam2.goalsFor = curAwayTeam2.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam2.goalsAgainst = curAwayTeam2.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam2.gamesPlayed = curAwayTeam2.gamesPlayed + 1;
                    // console.log(curHomeTeam2);
                }
                else {
                    //console.log("here adding stats away team lost already in array "+curAwayTeam2.name);
                    curAwayTeam2.round = curRound;
                    curAwayTeam2.points = curAwayTeam2.points + 0;
                    curAwayTeam2.goalsFor = curAwayTeam2.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam2.goalsAgainst = curAwayTeam2.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam2.gamesPlayed = curAwayTeam2.gamesPlayed + 1;
                    //console.log(curHomeTeam2);
                }
            }

        }


    }
    //console.log("fullSet:");
    //console.log(dataRounds);
    drawGraph(dataRounds);
    //data
    //var one = d3.sum(data2008);
    //console.log(one);
    //console.log(data2008);
}

function Team(points, name, goalsFor, goalsAgainst, played, round, homeWins, awayWins) {

    this.round = +round;
    this.name = name;
    this.points = +points;
    this.goalsFor = +goalsFor;
    this.goalsAgainst = +goalsAgainst;
    this.gamesPlayed = +played;
    this.homeWins = +homeWins;
    this.awayWins = +awayWins;

}

Team.prototype.toString = function teamToString() {

    return "Round: " + this.round + " Name: " + this.name + " Points: " + this.points + "" +
            " GoalsFor: " + this.goalsFor + " GoalsAgainst: " + this.goalsAgainst + "" +
            " GamesPlayed: " + this.gamesPlayed;

};

function contains(a, obj) {
    for (var i = 0; i < a.length; i++) {
        if (a[i] === obj) {
            //console.log(a[i]+" "+obj);
            return true;
        }
       // console.log(a[i]+" "+obj);
    }

    return false;
}

function drawGraph(data) {

    //notes
    //.chart is a class selector (e.g. to select <div class="chart"> )
    // you need ot use the .


    //console.log("graph drawing code starts :\n");

    var toGraph = [];

    //first get the correct round to graph
    var currentRoundData = data.get(currentRound);

    var workingSet = d3.map(currentRoundData);

    workingSet.forEach(function (entry) {
        if(contains(comparing,workingSet.get(entry).name))
            toGraph.push(workingSet.get(entry));
    });


    var margin = {top: 100, right: 20, bottom: 50, left: 100},
            width = 960 - margin.left - margin.right,
            height = 500 - margin.top - margin.bottom;

    var x = d3.scale.ordinal()
            .rangeRoundBands([0, width], .1);

    var y = d3.scale.linear()
            .range([height, 0]);

    var xAxis = d3.svg.axis()
            .scale(x)
            .orient("bottom");

    var yAxis = d3.svg.axis()
            .scale(y)
            .orient("left")
            .ticks(5, "Goals");

    var svg = d3.select("body").append("svg")
            .attr("width", width + margin.left + margin.right)
            .attr("height", height + margin.top + margin.bottom)
            .append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

    console.log(toGraph);
    x.domain(toGraph.map(function (d) {
        return d.name;
    }));
    y.domain([0, d3.max(toGraph, function (d) {
        return d.points;
    })]);

    svg.append("g")
            .attr("class", "x axis")
            .attr("transform", "translate(0," + height + ")")
            .call(xAxis)
            .selectAll(".tick text")
            .call(wrap, x.rangeBand())
    svg.append("text")
            .attr("class", "x label")
            .attr("text-anchor", "middle")
            .attr("x", width-(width/2))
            .attr("y", height + 45)
            .text("Teams");
    svg.append("text")
            .data(toGraph)
            .attr("x", (width / 2))
            .attr("y", 0 - (margin.top / 2))
            .attr("text-anchor", "middle")
            .style("font-size", "24px")
            .style("text-decoration", "underline")
            .text("Points for "+ getYearText()+" Season, "+getRoundText());

    svg.append("g")
            .attr("class", "y axis")
            .call(yAxis)
            .append("text")
            .attr("transform", "rotate(-90)")
            .attr("y", 8)
            .attr("dy", "0.75em")
            .style("text-anchor", "end")
            .text("Points");

    svg.selectAll(".bar")
            .data(toGraph)
            .enter().append("rect")
            .attr("class", "bar")
            .attr("x", function (d) {
                return x(d.name);
            })
            .attr("width", x.rangeBand())
            .attr("y", function (d) {
                return y(d.points);
            })
            .attr("height", function (d) {
                return height - y(d.points);

            });
    svg.selectAll(".text")
            .data(toGraph)
            .enter()
            .append("text")
            .text(function(d) {
                return d.points;
            })
            .attr("x", function(d) {
                return x(d.name);
            })
            .attr("y", function(d) {
                return y(d.points);
            });



    function wrap(text, width) {
        text.each(function () {
            var text = d3.select(this),
                    words = text.text().split(/\s+/).reverse(),
                    word,
                    line = [],
                    lineNumber = 0,
                    lineHeight = 1.1, // ems
                    y = text.attr("y"),
                    dy = parseFloat(text.attr("dy")),
                    tspan = text.text(null).append("tspan").attr("x", 0).attr("y", y).attr("dy", dy + "em");
            while (word = words.pop()) {
                line.push(word);
                tspan.text(line.join(" "));
                if (tspan.node().getComputedTextLength() > width) {
                    line.pop();
                    tspan.text(line.join(" "));
                    line = [word];
                    tspan = text.append("tspan").attr("x", 0).attr("y", y).attr("dy",
                                    ++lineNumber * lineHeight + dy + "em").text(word);
                }
            }
        });
    }




}


//have a map with key: 1 for round one
//and have the values as all the games played
//in round 1 so that way you can show standings
//by round
//somehow keep the team scores up to date
//each round intializes obecjects for each team
//it then adds to the teams GF GA and points as
//it encounters games with them?
//for the next round it copys over the teams from prev
//round and updates them?
//graph should be able to show the rounds as they progress
//eg points welly pulse have after first round (could be zero)

//copy over from round to round?

function manipulateDataDonut(home) {
    d3.select("svg").remove();
    data = allData;
    var isAllData = false;

    var currentData = getYearForm();
    if(currentData==allData) isAllData=true;

    //scores for each team

    console.log("currentData len: " + currentData.size());

    var dataRounds = d3.map(dataRounds);

    for (var i = 0; i < currentData.size(); i++) {
        var curRound = currentData.get(i).Round;
        //add the current round to the array if its not there
        if (!dataRounds.has(curRound)) {
            //initialize the map inside the current round
            if (curRound == 1) {
                dataRounds.set(curRound, d3.map());
                console.log(dataRounds.get(curRound));
            }
            else {
                //dataRounds.set(curRound, d3.map());
                //console.log("first" + curRound);
                var toSet = dataRounds.get(curRound - 1);
                var count = 1;
                while (toSet == undefined) {
                    toSet = dataRounds.get(curRound - count);
                    count++;
                }
                //console.log(toSet);
                //console.log("second");
                //var arraty = []
                //var newS =  arraty.slice();
                var newMap = owl.deepCopy(toSet);
                //for (var x in toSet)
                //    newMap[x] = toSet[x];
                //this is causing the error
                //want it so it adds teams points and score for each round
                //console.log("Setting ROUND: "+curRound+" toSet "+toSet.get("Central Pulse"));
                //console.log(newMap.size());
                dataRounds.set(curRound, newMap);
            }

            //get the map that will contain all the teams
            //for the current round
            var curMap = dataRounds.get(curRound);
            //console.log("retrieving map " + curRound + " " + curMap);
            //console.log(dataRounds);

            //initialize Home team
            if (!curMap.has(currentData.get(i).HomeTeam)) {
                if (currentData.get(i).HomeScore > currentData.get(i).AwayScore) {
                    //if they won there first game
                    //console.log("initializing home team");
                    curMap.set(currentData.get(i).HomeTeam, new Team(2, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound,1,0));
                }
                else {
                    //if not
                    curMap.set(currentData.get(i).HomeTeam, new Team(0, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound,0,0));

                }
            }

            //add stats to home team
            //if they are already in the map
            else if (curMap.has(currentData.get(i).HomeTeam)) {
                //console.log("error here:");
                //console.log(curMap);
                //console.log(curMap.get(currentData.get(i).HomeTeam));
                //curMap returns a TEAM object
                var curHomeTeam = curMap.get(currentData.get(i).HomeTeam);


                if (currentData.get(i).HomeScore > currentData.get(i).AwayScore) {
                    //check this is working
                    //console.log("here adding stats home team won already in array "+curHomeTeam.name);
                    curHomeTeam.round = curRound;
                    curHomeTeam.points = curHomeTeam.points + 2;
                    curHomeTeam.goalsFor = curHomeTeam.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam.goalsAgainst = curHomeTeam.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam.gamesPlayed = curHomeTeam.gamesPlayed + 1;
                    curHomeTeam.homeWins += 1;

                    //console.log(curHomeTeam);
                }
                else if (currentData.get(i).HomeScore < currentData.get(i).AwayScore) {
                    //check this is working
                    //console.log("here adding stats home team lost already in the array "+curHomeTeam.name);
                    curHomeTeam.round = curRound;
                    curHomeTeam.points = curHomeTeam.points + 0;
                    curHomeTeam.goalsFor = curHomeTeam.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam.goalsAgainst = curHomeTeam.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam.gamesPlayed = curHomeTeam.gamesPlayed + 1;
                    curHomeTeam.homeWins += 0;
                    //console.log(curHomeTeam);
                }

            }

            //initialize Away team
            if (!curMap.has(currentData.get(i).AwayTeam)) {
                //if they won
                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    curMap.set(currentData.get(i).AwayTeam, new Team(2, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound,0,1));
                }
                //if they lost
                else {
                    curMap.set(currentData.get(i).AwayTeam, new Team(0, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound,0,0));
                }
            }
            //add stats to away team
            else if (curMap.has(currentData.get(i).AwayTeam)) {
                //console.log("error here:");
                //console.log(curMap);
                //console.log(curMap.get(currentData.get(i).HomeTeam));
                //curMap returns a TEAM object
                var curAwayTeam = curMap.get(currentData.get(i).AwayTeam);

                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    //check this is working
                    //console.log("here adding stats away team won already in the array "+curAwayTeam.name);
                    curAwayTeam.round = curRound;
                    curAwayTeam.points = curAwayTeam.points + 2;
                    curAwayTeam.goalsFor = curAwayTeam.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam.goalsAgainst = curAwayTeam.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam.gamesPlayed = curAwayTeam.gamesPlayed + 1;
                    curHomeTeam.awayWins += 1;
                    //console.log(curAwayTeam);
                }
                //away team lost
                else if (currentData.get(i).AwayScore < currentData.get(i).HomeScore) {
                    //console.log("here adding stats away team lost already in the array "+curAwayTeam.name);
                    curAwayTeam.round = curRound;
                    curAwayTeam.points = curAwayTeam.points + 0;
                    curAwayTeam.goalsFor = curAwayTeam.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam.goalsAgainst = curAwayTeam.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam.gamesPlayed = curAwayTeam.gamesPlayed + 1;

                    //console.log(curAwayTeam);
                }


            }

        }
        //already has current round eg rnd 1
        else if (dataRounds.has(curRound)) {

            //get the map that will contain all the teams
            //for the current round
            var currentMap = dataRounds.get(curRound);
            //initialize Home team
            if (!currentMap.has(currentData.get(i).HomeTeam)) {
                var homeTeam = currentData.get(i);
                var awayteam = currentData.get(i);
                if (homeTeam.HomeScore > awayteam.AwayScore) {
                    currentMap.set(currentData.get(i).HomeTeam, new Team(2, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound,1,0));
                }
                else {
                    currentMap.set(currentData.get(i).HomeTeam, new Team(0, currentData.get(i).HomeTeam,
                            currentData.get(i).HomeScore, currentData.get(i).AwayScore, 1, curRound,0,0));
                }
            }
            //add points home team
            else if (currentMap.has(currentData.get(i).HomeTeam)) {
                var curHomeTeam2 = currentMap.get(currentData.get(i).HomeTeam);
                if(isAllData){
                    curHomeTeam2 = curMap.get(currentData.get(i).HomeTeam);
                    //console.log("went in here ALLDATA bug");
                }
                if (currentData.get(i).HomeScore > currentData.get(i).AwayScore) {
                    //console.log("here adding stats home team won already in array "+curHomeTeam2.name);
                    curHomeTeam2.round = curRound;
                    curHomeTeam2.points = curHomeTeam2.points + 2;
                    curHomeTeam2.goalsFor = curHomeTeam2.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam2.goalsAgainst = curHomeTeam2.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam2.gamesPlayed = curHomeTeam2.gamesPlayed + 1;
                    curHomeTeam2.homeWins += 1;
                    //console.log(curHomeTeam2);
                }
                else {
                    //console.log("here adding stats home team lost already in array "+curHomeTeam2.name);
                    curHomeTeam2.round = curRound;
                    curHomeTeam2.points = curHomeTeam2.points + 0;
                    curHomeTeam2.goalsFor = curHomeTeam2.goalsFor + currentData.get(i).HomeScore;
                    curHomeTeam2.goalsAgainst = curHomeTeam2.goalsAgainst + currentData.get(i).AwayScore;
                    curHomeTeam2.gamesPlayed = curHomeTeam2.gamesPlayed + 1;
                    //console.log(curHomeTeam2);
                }

            }

            //initialize away team
            if (!currentMap.has(currentData.get(i).AwayTeam)) {
                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    currentMap.set(currentData.get(i).AwayTeam, new Team(2, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound,0,1));
                }
                else {
                    currentMap.set(currentData.get(i).AwayTeam, new Team(0, currentData.get(i).AwayTeam,
                            currentData.get(i).AwayScore, currentData.get(i).HomeScore, 1, curRound,0,0));
                }
            }

            //gotta add stats if they are already there. (only for 2011)
            else if (currentMap.has(currentData.get(i).AwayTeam)) {
                var curAwayTeam2 = currentMap.get(currentData.get(i).AwayTeam);
                if (currentData.get(i).AwayScore > currentData.get(i).HomeScore) {
                    //console.log("here adding stats away team won already in array "+curAwayTeam2.name);
                    curAwayTeam2.round = curRound;
                    curAwayTeam2.points = curAwayTeam2.points + 2;
                    curAwayTeam2.goalsFor = curAwayTeam2.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam2.goalsAgainst = curAwayTeam2.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam2.gamesPlayed = curAwayTeam2.gamesPlayed + 1;
                    curAwayTeam2.awayWins += 1;
                    // console.log(curHomeTeam2);
                }
                else {
                    //console.log("here adding stats away team lost already in array "+curAwayTeam2.name);
                    curAwayTeam2.round = curRound;
                    curAwayTeam2.points = curAwayTeam2.points + 0;
                    curAwayTeam2.goalsFor = curAwayTeam2.goalsFor + currentData.get(i).AwayScore;
                    curAwayTeam2.goalsAgainst = curAwayTeam2.goalsAgainst + currentData.get(i).HomeScore;
                    curAwayTeam2.gamesPlayed = curAwayTeam2.gamesPlayed + 1;
                    //console.log(curHomeTeam2);
                }
            }

        }


    }
    console.log("fullSetDonut:");
    console.log(dataRounds);
    if(home==true){
        drawDonutGraphHome(dataRounds);
    }
    else{
        drawDonutGraphAway(dataRounds);
    }
    //data
    //var one = d3.sum(data2008);
    //console.log(one);
    //console.log(data2008);
}
function drawDonutGraphHome(data){

    var toGraph = [];

    var currentRoundData = data.get(currentRound);
    console.log("Current Round");
    console.log(currentRoundData);

    var workingSet = d3.map(currentRoundData);

    workingSet.forEach(function (entry) {
        if(contains(comparing,workingSet.get(entry).name))
            toGraph.push(workingSet.get(entry));
    });



    //console.log("Donut Stuff");
    //console.log(toGraph);

    var width = 960,
            height = 500,
            radius = Math.min(width, height) / 2;

    var color = d3.scale.ordinal()
            .range(["#3182bd","#008000","#ffffff","#f08000","#c080b0","#4da64d","#dddddd"]);

    var arc = d3.svg.arc()
            .outerRadius(radius - 10)
            .innerRadius(radius - 70);

    var pie = d3.layout.pie()
            .sort(null)
            .value(function(d) { return d.homeWins; });

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");



        toGraph.forEach(function(d) {
            d.homeWins = +d.homeWins;
        });

        var g = svg.selectAll(".arc")
                .data(pie(toGraph))
                .enter().append("g")
                .attr("class", "arc");

        g.append("path")
                .attr("d", arc)
                .style("fill", function(d) { return color(d.data.name); });

        g.append("text")
                .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")"; })
                .attr("dy", ".35em")
                .style("text-anchor", "middle")
                .text(function(d) { return d.data.name+" "+d.data.homeWins; });




}


function drawDonutGraphAway(data){

    var toGraph = [];

    var currentRoundData = data.get(currentRound);
    console.log("Current Round");
    console.log(currentRoundData);

    var workingSet = d3.map(currentRoundData);

    workingSet.forEach(function (entry) {
        if(contains(comparing,workingSet.get(entry).name))
            toGraph.push(workingSet.get(entry));
    });



    //console.log("Donut Stuff");
   // console.log(toGraph);

    var width = 960,
            height = 500,
            radius = Math.min(width, height) / 2;

    var color = d3.scale.ordinal()
            .range(["#3182bd","#008000","#ffffff","#f08000","#c080b0","#4da64d","#dddddd"]);

    var arc = d3.svg.arc()
            .outerRadius(radius - 10)
            .innerRadius(radius - 70);

    var pie = d3.layout.pie()
            .sort(null)
            .value(function(d) { return d.awayWins; });

    var svg = d3.select("body").append("svg")
            .attr("width", width)
            .attr("height", height)
            .append("g")
            .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

    toGraph.forEach(function(d) {
        d.awayWins = +d.awayWins;
    });

    var g = svg.selectAll(".arc")
            .data(pie(toGraph))
            .enter().append("g")
            .attr("class", "arc");

    g.append("path")
            .attr("d", arc)
            .style("fill", function(d) { return color(d.data.name); });

    g.append("text")
            .attr("transform", function(d) { return "translate(" + arc.centroid(d) + ")"; })
            .attr("dy", ".35em")
            .style("text-anchor", "middle")
            .text(function(d) { return d.data.name+" "+d.data.awayWins; });

}